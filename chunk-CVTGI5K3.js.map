{"version":3,"sources":["node_modules/prosemirror-tables/dist/index.js","node_modules/@tiptap/extension-table/dist/index.js","node_modules/@tinkoff/tui-editor/fesm2015/tinkoff-tui-editor-extensions-table.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { NodeSelection as NodeSelection2, Selection, SelectionRange, TextSelection } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */new WeakMap();\n  readFromCache = key => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return {\n        left,\n        top,\n        right,\n        bottom\n      };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table),\n    height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const {\n        colspan,\n        rowspan,\n        colwidth\n      } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;else (problems || (problems = [])).push({\n            type: \"collision\",\n            row,\n            pos,\n            n: colspan - w\n          });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2,\n              prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing) (problems || (problems = [])).push({\n      type: \"missing\",\n      row,\n      n: missing\n    });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      const prevRow = table.child(j);\n      for (let i = 0; i < prevRow.childCount; i++) {\n        const cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n      }\n    }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated) map.problems.unshift({\n      type: \"colwidth mismatch\",\n      pos,\n      colwidth: updated\n    });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(s => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth) attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: {\n      default: 1\n    },\n    rowspan: {\n      default: 1\n    },\n    colwidth: {\n      default: null\n    }\n  };\n  for (const prop in extraAttrs) cellAttrs[prop] = {\n    default: extraAttrs[prop].default\n  };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{\n        tag: \"table\"\n      }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{\n        tag: \"tr\"\n      }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"td\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"th\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan - n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan + n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map(pos => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection()) return _CellSelection.rowSelection($anchorCell, $headCell);else if (tableChanged && this.isColSelection()) return _CellSelection.colSelection($anchorCell, $headCell);else return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n    const sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height) $headCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n    } else {\n      if (headRect.top > 0) $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width) $headCell = doc.resolve(tableStart + map.map[map.width * (headRect.top + 1) - 1]);\n    } else {\n      if (headRect.left > 0) $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width) $anchorCell = doc.resolve(tableStart + map.map[map.width * (anchorRect.top + 1) - 1]);\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: \"selectedCell\"\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({\n  $from,\n  $to\n}) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({\n  $from,\n  $to\n}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i;\n    last = i;\n  }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Selection as Selection2, TextSelection as TextSelection2 } from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let {\n    content,\n    openStart,\n    openEnd\n  } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema,\n    rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice2(cells, left, right)).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice2(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const {\n        rowspan,\n        colspan\n      } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return {\n    height: rows.length,\n    width,\n    rows\n  };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({\n  width,\n  height,\n  rows\n}, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({\n          ...cell.attrs,\n          rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n        }, cell.content);\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return {\n    width,\n    height,\n    rows\n  };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const {\n        top: cellTop,\n        left: cellLeft\n      } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill({\n        ...cell.attrs,\n        rowspan: cellTop + cell.attrs.rowspan - top\n      }));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const {\n    top,\n    left\n  } = rect;\n  const right = left + cells.width,\n    bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice2(cells.rows[row - top], 0, 0));\n  }\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection2.near(sel.$headCell, dir));\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection2.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);else if (dir < 0) newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice3(baseContent, 0, 0));\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {\n      width: 1,\n      height: 1,\n      rows: [Fragment3.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n    };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2)) return null;\n  const {\n    $head\n  } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport { Decoration as Decoration2, DecorationSet as DecorationSet2 } from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\"tableColumnResizing\");\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? {\n          class: \"resize-cursor\"\n        } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n        },\n        mouseleave: view => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null) return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0) return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const {\n        left,\n        right\n      } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, \"left\", handleWidth);else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n        setDragging: null\n      }));\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, {\n  colspan,\n  colwidth\n}) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n      domWidth -= colwidth[i];\n      parts--;\n    }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\") target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const {\n    pos\n  } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setHandle: value\n  }));\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, {\n      ...attrs,\n      colwidth\n    });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport { TextSelection as TextSelection3 } from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map.findCell($pos.pos - tableStart);\n  return {\n    ...rect,\n    tableStart,\n    map,\n    table\n  };\n}\nfunction addColumn(tr, {\n  map,\n  tableStart,\n  table\n}, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, {\n  map,\n  table,\n  tableStart\n}, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height;) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map.colCount(pos)));\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++) if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell) return false;\n  return true;\n}\nfunction addRow(tr, {\n  map,\n  tableStart,\n  table\n}, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, {\n  map,\n  table,\n  tableStart\n}, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create({\n        ...attrs,\n        rowspan: cell.attrs.rowspan - 1\n      }, cell.content);\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({\n  width,\n  height,\n  map\n}, rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n  const rect = selectedRect(state),\n    {\n      map\n    } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node\n  }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = {\n        ...baseAttrs,\n        rowspan: 1\n      };\n      if (baseAttrs.colspan > 1) baseAttrs = {\n        ...baseAttrs,\n        colspan: 1\n      };\n      const rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? {\n        ...baseAttrs,\n        colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n      } : baseAttrs);\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row,\n            col\n          }).createAndFill(attrs[i]));\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {\n          ...node.attrs,\n          [name]: value\n        });\n      });else tr.setNodeMarkup($cell.pos, null, {\n        ...$cell.nodeAfter.attrs,\n        [name]: value\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const cells = rect.map.cellsInRect(type == \"column\" ? {\n        left: rect.left,\n        top: 0,\n        right: rect.right,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: 0,\n        top: rect.top,\n        right: rect.map.width,\n        bottom: rect.bottom\n      } : rect);\n      const nodes = cells.map(pos => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const {\n          deleted,\n          pos\n        } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n  });\n}\nexport { CellBookmark, CellSelection, ResizeState, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, colCount, columnIsHeader, columnResizing, columnResizingPluginKey, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setCellAttr, splitCell, splitCellWithType, tableEditing, tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumnsOnResize };","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? `${hasWidth}px` : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) {\n        fixedWidth = false;\n      }\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width !== cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`;\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = `${totalWidth}px`;\n  }\n}\nclass TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n  update(node) {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    this.node = node;\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(mutation) {\n    return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));\n  }\n}\nfunction createCell(cellType, cellContent) {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n  return cellType.createAndFill();\n}\nfunction getTableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n  const types = getTableNodeTypes(schema);\n  const headerCells = [];\n  const cells = [];\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent);\n    if (cell) {\n      cells.push(cell);\n    }\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent);\n      if (headerCell) {\n        headerCells.push(headerCell);\n      }\n    }\n  }\n  const rows = [];\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n  }\n  return types.table.createChecked(null, rows);\n}\nfunction isCellSelection(value) {\n  return value instanceof CellSelection;\n}\nconst deleteTableWhenAllCellsSelected = ({\n  editor\n}) => {\n  const {\n    selection\n  } = editor.state;\n  if (!isCellSelection(selection)) {\n    return false;\n  }\n  let cellCount = 0;\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table';\n  });\n  table === null || table === void 0 ? void 0 : table.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false;\n    }\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1;\n    }\n  });\n  const allCellsSelected = cellCount === selection.ranges.length;\n  if (!allCellsSelected) {\n    return false;\n  }\n  editor.commands.deleteTable();\n  return true;\n};\nconst Table = Node.create({\n  name: 'table',\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false\n    };\n  },\n  content: 'tableRow+',\n  tableRole: 'table',\n  isolating: true,\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'table'\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\n  },\n  addCommands() {\n    return {\n      insertTable: ({\n        rows = 3,\n        cols = 3,\n        withHeaderRow = true\n      } = {}) => ({\n        tr,\n        dispatch,\n        editor\n      }) => {\n        const node = createTable(editor.schema, rows, cols, withHeaderRow);\n        if (dispatch) {\n          const offset = tr.selection.anchor + 1;\n          tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset)));\n        }\n        return true;\n      },\n      addColumnBefore: () => ({\n        state,\n        dispatch\n      }) => {\n        return addColumnBefore(state, dispatch);\n      },\n      addColumnAfter: () => ({\n        state,\n        dispatch\n      }) => {\n        return addColumnAfter(state, dispatch);\n      },\n      deleteColumn: () => ({\n        state,\n        dispatch\n      }) => {\n        return deleteColumn(state, dispatch);\n      },\n      addRowBefore: () => ({\n        state,\n        dispatch\n      }) => {\n        return addRowBefore(state, dispatch);\n      },\n      addRowAfter: () => ({\n        state,\n        dispatch\n      }) => {\n        return addRowAfter(state, dispatch);\n      },\n      deleteRow: () => ({\n        state,\n        dispatch\n      }) => {\n        return deleteRow(state, dispatch);\n      },\n      deleteTable: () => ({\n        state,\n        dispatch\n      }) => {\n        return deleteTable(state, dispatch);\n      },\n      mergeCells: () => ({\n        state,\n        dispatch\n      }) => {\n        return mergeCells(state, dispatch);\n      },\n      splitCell: () => ({\n        state,\n        dispatch\n      }) => {\n        return splitCell(state, dispatch);\n      },\n      toggleHeaderColumn: () => ({\n        state,\n        dispatch\n      }) => {\n        return toggleHeader('column')(state, dispatch);\n      },\n      toggleHeaderRow: () => ({\n        state,\n        dispatch\n      }) => {\n        return toggleHeader('row')(state, dispatch);\n      },\n      toggleHeaderCell: () => ({\n        state,\n        dispatch\n      }) => {\n        return toggleHeaderCell(state, dispatch);\n      },\n      mergeOrSplit: () => ({\n        state,\n        dispatch\n      }) => {\n        if (mergeCells(state, dispatch)) {\n          return true;\n        }\n        return splitCell(state, dispatch);\n      },\n      setCellAttribute: (name, value) => ({\n        state,\n        dispatch\n      }) => {\n        return setCellAttr(name, value)(state, dispatch);\n      },\n      goToNextCell: () => ({\n        state,\n        dispatch\n      }) => {\n        return goToNextCell(1)(state, dispatch);\n      },\n      goToPreviousCell: () => ({\n        state,\n        dispatch\n      }) => {\n        return goToNextCell(-1)(state, dispatch);\n      },\n      fixTables: () => ({\n        state,\n        dispatch\n      }) => {\n        if (dispatch) {\n          fixTables(state);\n        }\n        return true;\n      },\n      setCellSelection: position => ({\n        tr,\n        dispatch\n      }) => {\n        if (dispatch) {\n          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\n          // @ts-ignore\n          tr.setSelection(selection);\n        }\n        return true;\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true;\n        }\n        if (!this.editor.can().addRowAfter()) {\n          return false;\n        }\n        return this.editor.chain().addRowAfter().goToNextCell().run();\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected\n    };\n  },\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable;\n    return [...(isResizable ? [columnResizing({\n      handleWidth: this.options.handleWidth,\n      cellMinWidth: this.options.cellMinWidth,\n      // @ts-ignore (incorrect type)\n      View: this.options.View,\n      // TODO: PR for @types/prosemirror-tables\n      // @ts-ignore (incorrect type)\n      lastColumnResizable: this.options.lastColumnResizable\n    })] : []), tableEditing({\n      allowTableNodeSelection: this.options.allowTableNodeSelection\n    })];\n  },\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context))\n    };\n  }\n});\nexport { Table, createTable, Table as default };\n","import { mergeAttributes } from '@tiptap/core';\nimport { Table } from '@tiptap/extension-table';\nfunction tuiCreateColGroup(node, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0;\n  let fixedWidth = true;\n  const cols = [];\n  const row = node.firstChild;\n  if (!row) {\n    return {};\n  }\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth === null || colwidth === void 0 ? void 0 : colwidth[j];\n      const cssWidth = hasWidth ? `${hasWidth}px` : ``;\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) {\n        fixedWidth = false;\n      }\n      cols.push([`col`, cssWidth ? {\n        style: `width: ${cssWidth}`\n      } : {}]);\n    }\n  }\n  const tableWidth = fixedWidth ? `${totalWidth}px` : ``;\n  const tableMinWidth = fixedWidth ? `` : `${totalWidth}px`;\n  const colgroup = [`colgroup`, {}, ...cols];\n  return {\n    colgroup,\n    tableWidth,\n    tableMinWidth\n  };\n}\nconst TuiTable = Table.extend({\n  renderHTML({\n    node,\n    HTMLAttributes\n  }) {\n    const {\n      colgroup,\n      tableWidth,\n      tableMinWidth\n    } = tuiCreateColGroup(node, this.options.cellMinWidth);\n    return [`div`, {\n      class: `tui-table-wrapper`\n    }, [`table`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n      style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`\n    }), colgroup, [`tbody`, 0]]];\n  }\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiTable };\n"],"mappings":"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","names":["readFromCache","addToCache","cache","key","value","cachePos","i","TableMap","width","height","map","problems","pos","curPos","left","top","right","bottom","j","axis","dir","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","rect","result","seen","row","col","index","table","rowStart","rowEnd","rowEndIndex","computeMap","findWidth","mapPos","colWidths","e","rowNode","cellNode","colspan","rowspan","colwidth","h","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","findBadColWidths","hasRowSpan","rowWidth","prevRow","cell","node","updated","attrs","colWidth","freshColWidth","tableNodeTypes","schema","result","name","type","role","tableEditingKey","PluginKey","cellAround","$pos","d","cellWrapping","isInTable","state","$head","selectionCell","sel","$cell","cellNear","after","pos","before","pointsAtCell","moveCellForward","inSameTable","$cellA","$cellB","nextCell","$pos","axis","dir","table","map","TableMap","tableStart","moved","removeColSpan","attrs","pos","n","result","__spreadProps","__spreadValues","w","addColSpan","i","columnIsHeader","col","headerCell","tableNodeTypes","row","CellSelection","_CellSelection","Selection","$anchorCell","$headCell","rect","doc","cells","p","ranges","cell","from","SelectionRange","mapping","pointsAtCell","inSameTable","tableChanged","TextSelection","seen","rows","rowContent","index","cellRect","extraLeft","extraRight","Fragment","fragment","Slice","tr","content","mapFrom","$from","$to","sel","node","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","other","json","anchorCell","headCell","CellBookmark","_CellBookmark","anchor","head","drawCellSelection","state","Decoration","DecorationSet","isCellBoundarySelection","afterFrom","beforeTo","depth","d","isTextSelectionAcrossCells","fromCellBoundaryNode","toCellBoundaryNode","normalizeSelection","allowTableNodeSelection","normalize","role","NodeSelection","$cell","start","lastCell","fixTablesKey","PluginKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","j","child","scan","e","fixTables","oldState","check","fixTable","tablePos","mustAdd","prob","first","last","end","add","nodes","side","pastedCells","slice","openStart","openEnd","schema","left","right","fitSlice","ensureRectangular","widths","rowspan","colspan","r","width","empty","nodeType","Transform","clipCells","height","newWidth","newHeight","added","newRows","frag","source","growTable","types","emptyHead","rowEnd","rowNode","start2","header","emptyRow","isolateHorizontal","top","found","cellTop","cellLeft","isolateVertical","bottom","updatePos","insertCells","dispatch","recomp","to","handleKeyDown","keydownHandler","arrow","shiftArrow","deleteCellSelection","maybeSetSelection","selection","view","atEndOfCell","$next","newSel","cellSel","$head","baseContent","handleTripleClick","cellAround","handlePaste","_","isInTable","selectionCell","handleMouseDown","startEvent","_a","startDOMCell","domInCell","$anchor","setCellSelection","cellUnderMouse","$anchor2","event","starting","tableEditingKey","stop","move","_event","parent","cellPos","dirStr","dom","mousePos","TableView","cellMinWidth","updateColumnsOnResize","record","colgroup","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","colwidth","hasWidth","cssWidth","after","columnResizingPluginKey","columnResizing","handleWidth","View","lastColumnResizable","plugin","Plugin","ResizeState","prev","pluginState","handleMouseMove","handleMouseLeave","handleMouseDown2","handleDecorations","_ResizeState","activeHandle","dragging","action","handle","target","domCellAround","edgeCell","updateHandle","currentColWidth","finish","event2","pluginState2","updateColumnWidth","draggedWidth","dragged","displayColumnWidth","domWidth","parts","value","mapIndex","zeroes","decorations","selectedRect","addColumn","refColumn","type","addColumnBefore","addColumnAfter","removeColumn","mapStart","deleteColumn","rowIsHeader","addRow","rowPos","refRow","addRowBefore","addRowAfter","removeRow","nextRow","copy","newPos","deleteRow","isEmpty","c","cellsOverlapRectangle","indexTop","indexLeft","indexBottom","indexRight","mergeCells","mergedPos","mergedCell","mapped","splitCell","nodeTypes","splitCellWithType","getCellType","cellNode","cellWrapping","baseAttrs","setCellAttr","name","deprecated_toggleHeader","isHeaderEnabledByType","cellPositions","toggleHeader","options","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","relativeCellPos","toggleHeaderRow","toggleHeaderColumn","toggleHeaderCell","findNextCell","before","lastChild","rowStart","goToNextCell","direction","moveCellForward","deleteTable","tableEditing","set","deleted","updateColumns","node","colgroup","table","cellMinWidth","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","row","i","col","colspan","colwidth","j","hasWidth","cssWidth","after","TableView","mutation","createCell","cellType","cellContent","getTableNodeTypes","schema","roles","type","nodeType","createTable","rowsCount","colsCount","withHeaderRow","types","headerCells","cells","index","cell","headerCell","rows","isCellSelection","value","CellSelection","deleteTableWhenAllCellsSelected","editor","selection","cellCount","findParentNodeClosestToPos","Table","Node","HTMLAttributes","mergeAttributes","cols","tr","dispatch","offset","TextSelection","state","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","deleteTable","mergeCells","splitCell","toggleHeader","toggleHeaderCell","name","setCellAttr","goToNextCell","fixTables","position","columnResizing","tableEditing","extension","context","callOrReturn","getExtensionField","tuiCreateColGroup","node","cellMinWidth","overrideCol","overrideValue","totalWidth","fixedWidth","cols","row","i","col","colspan","colwidth","j","hasWidth","cssWidth","tableWidth","tableMinWidth","TuiTable","Table","HTMLAttributes","colgroup","mergeAttributes"],"x_google_ignoreList":[0,1,2]}