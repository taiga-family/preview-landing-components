{"version":3,"sources":["node_modules/@tinkoff/tui-editor/fesm2015/tinkoff-tui-editor-utils.js"],"sourcesContent":["import { tuiClamp, TuiDocumentSelectionException, tuiIsNodeIn, tuiParseColor } from '@taiga-ui/cdk';\nimport { Node } from 'prosemirror-model';\nimport { getHTMLFromFragment } from '@tiptap/core';\nfunction tuiDeleteNode(state, dispatch, nodeName) {\n  const position = state.selection.$anchor;\n  for (let depth = position.depth; depth > 0; depth--) {\n    const node = position.node(depth);\n    if (node.type.name === nodeName) {\n      if (dispatch) {\n        dispatch(state.tr.delete(position.before(depth), position.after(depth)).scrollIntoView());\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction tuiGetElementPoint(x, y, element) {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  return [tuiClamp(x - left, 0, width) / width, tuiClamp(y - top, 0, height) / height];\n}\nfunction tuiGetGradientData(gradient) {\n  return gradient.slice(0, Math.max(0, gradient.length - 1)).replace(`linear-gradient(`, ``);\n}\nfunction hasAttributes(markAttributes, attributes) {\n  const keys = Object.keys(attributes);\n  return !keys.length || !!keys.filter(key => attributes[key] === markAttributes[key]).length;\n}\nfunction findMarkInSet(marks, markType, attributes = {}) {\n  return marks.find(({\n    attrs,\n    type\n  }) => type === markType && hasAttributes(attrs, attributes)) || null;\n}\nfunction tuiGetMarkRange(pos, type, attributes = {}) {\n  if (!pos || !type) {\n    return null;\n  }\n  const {\n    node,\n    offset\n  } = pos.parent.childAfter(pos.parentOffset);\n  if (!node) {\n    return null;\n  }\n  const mark = findMarkInSet(node.marks, type, attributes);\n  if (!mark) {\n    return null;\n  }\n  let startIndex = pos.index();\n  let startPos = pos.start() + offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + node.nodeSize;\n  findMarkInSet(node.marks, type, attributes);\n  while (startIndex > 0 && mark.isInSet(pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < pos.parent.childCount && !!findMarkInSet(pos.parent.child(endIndex).marks, type, attributes)) {\n    endPos += pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction tuiGetNestedNodes(node) {\n  const nodes = [];\n  // @note: the content field is not array type\n  node.content.forEach(child => {\n    if (child instanceof Node) {\n      nodes.push([child.type.name, child.attrs]);\n    }\n  });\n  return nodes;\n}\nfunction tuiGetSelectedContent(state, current) {\n  const currentNodeContent = current !== null && current !== void 0 ? current : state.selection.$head.parent.textContent;\n  const selected = state.doc.cut(state.selection.from, state.selection.to);\n  return selected.content.size ? getHTMLFromFragment(selected.content, state.schema) : currentNodeContent;\n}\nfunction tuiGetSelectionState(editor) {\n  var _a, _b, _c;\n  if (!editor) {\n    return {\n      before: ``,\n      after: ``\n    };\n  }\n  const {\n    $from,\n    $to\n  } = editor.state.selection;\n  let before = (_a = $from.nodeBefore) === null || _a === void 0 ? void 0 : _a.textContent;\n  before = ((before === null || before === void 0 ? void 0 : before.slice(((_b = (before === null || before === void 0 ? void 0 : before.lastIndexOf(` `)) || (before === null || before === void 0 ? void 0 : before.lastIndexOf(`\\n`))) !== null && _b !== void 0 ? _b : 0) + 1)) || ``).trim();\n  const after = ((_c = $to.nodeAfter) === null || _c === void 0 ? void 0 : _c.textContent.trim()) || ``;\n  return {\n    before,\n    after\n  };\n}\n\n/**\n * Provides document.execCommand('insertHTML', false, html) support to unsupported browser,\n * taking Undo stack into account if possible\n *\n * @throws Will throw an error if selection could not be retrieved\n *\n * @param doc document to execute on\n * @param html html to be inserted\n */\nfunction tuiInsertHtml(doc, html) {\n  if (doc.queryCommandSupported(`insertHTML`)) {\n    doc.execCommand(`insertHTML`, false, html);\n    return;\n  }\n  const selection = doc.getSelection();\n  if (!selection) {\n    throw new TuiDocumentSelectionException();\n  }\n  doc.execCommand(`ms-beginUndoUnit`);\n  const range = selection.getRangeAt(0);\n  const documentFragment = range.createContextualFragment(html);\n  range.deleteContents();\n  range.insertNode(documentFragment);\n  doc.execCommand(`ms-endUndoUnit`);\n}\n\n/**\n * Provides document.execCommand('insertText', false, text) support to unsupported browser,\n * taking Undo stack into account if possible\n *\n * @throws Will throw an error if selection could not be retrieved\n *\n * @param doc document to execute on\n * @param text text to be inserted\n */\nfunction tuiInsertText(doc, text) {\n  if (doc.queryCommandSupported(`insertText`)) {\n    doc.execCommand(`insertText`, false, text);\n    return;\n  }\n  const selection = doc.getSelection();\n  if (!selection) {\n    throw new TuiDocumentSelectionException();\n  }\n  doc.execCommand(`ms-beginUndoUnit`);\n  const range = selection.getRangeAt(0);\n  range.deleteContents();\n  range.insertNode(doc.createTextNode(text));\n  doc.execCommand(`ms-endUndoUnit`);\n}\n\n/**\n * Checks if selection is inside a specific selector\n * @param selection\n * @param selector\n * @return true if selection is completely inside a particular selector\n */\nfunction tuiIsSelectionIn({\n  anchorNode,\n  focusNode\n}, selector) {\n  // Even though focusNode/anchor-node are defined as Node, they can be null on initial nested document query\n  return !!anchorNode && !!focusNode && tuiIsNodeIn(anchorNode, selector) && tuiIsNodeIn(focusNode, selector);\n}\nfunction migration(element) {\n  Array.from(element.children).forEach(child => {\n    if (child.children.length) {\n      migration(child);\n    }\n    if (child.tagName === `FONT`) {\n      if (child.hasAttribute(`size`)) {\n        switch (child.getAttribute(`size`)) {\n          case `6`:\n            {\n              migrateHeading(`h1`, child);\n              break;\n            }\n          case `5`:\n            {\n              migrateHeading(`h2`, child);\n              break;\n            }\n          case `4`:\n            {\n              migrateParagraph(`17px`, child);\n              break;\n            }\n          case `3`:\n            {\n              migrateParagraph(`15px`, child);\n              break;\n            }\n          case `2`:\n            {\n              migrateParagraph(`13px`, child);\n              break;\n            }\n          default:\n            break;\n        }\n      } else if (child.hasAttribute(`color`)) {\n        migrateFontHighlight(child);\n      }\n    }\n  });\n}\nfunction migrateHeading(selector, element) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const heading = document.createElement(selector);\n  heading.innerHTML = element.innerHTML;\n  if (((_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) === `P`) {\n    const newRef = (_c = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.insertBefore(heading, element.parentElement);\n    (_d = element.parentElement) === null || _d === void 0 ? void 0 : _d.removeChild(element);\n    if ((newRef === null || newRef === void 0 ? void 0 : newRef.nextSibling) && !((_f = (_e = newRef === null || newRef === void 0 ? void 0 : newRef.nextSibling) === null || _e === void 0 ? void 0 : _e.textContent) === null || _f === void 0 ? void 0 : _f.trim())) {\n      (_h = (_g = newRef.nextSibling) === null || _g === void 0 ? void 0 : _g.parentElement) === null || _h === void 0 ? void 0 : _h.removeChild(newRef.nextSibling);\n    }\n  } else {\n    (_j = element.parentElement) === null || _j === void 0 ? void 0 : _j.replaceChild(heading, element);\n  }\n}\nfunction migrateParagraph(fontSize, element) {\n  var _a;\n  const p = document.createElement(`p`);\n  const span = document.createElement(`span`);\n  span.setAttribute(`style`, `font-size: ${fontSize}`);\n  span.innerHTML = element.innerHTML;\n  p.append(span);\n  (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.replaceChild(element.parentElement.tagName === `P` ? span : p, element);\n}\nfunction migrateFontHighlight(element) {\n  var _a;\n  const span = document.createElement(`span`);\n  span.setAttribute(`style`, `color: ${element.getAttribute(`color`)}`);\n  span.innerHTML = element.innerHTML;\n  (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.replaceChild(span, element);\n}\n/**\n * @description:\n * This converter help you to painlessly migrate old tags to the tui-editor[new]\n */\nfunction tuiLegacyEditorConverter(content) {\n  const tree = new DOMParser().parseFromString(content, `text/html`);\n  migration(tree.body);\n  return tree.body.innerHTML;\n}\n\n//\n// TypeScript parser based on Dean Taylor's answer:\n// https://stackoverflow.com/a/20238168/2706426\n//\n// SETUP CODE\nconst COMMA = `\\\\s*,\\\\s*`; // Allow space around comma.\nconst HEX = `#(?:[a-f0-9]{6}|[a-f0-9]{3})`; // 3 or 6 character form\nconst RGB = `\\\\(\\\\s*(?:\\\\d{1,3}\\\\s*,\\\\s*){2}\\\\d{1,3}\\\\s*\\\\)`; // \"(1, 2, 3)\"\nconst RGBA = `\\\\(\\\\s*(?:\\\\d{1,3}\\\\s*,\\\\s*){2}\\\\d{1,3}\\\\s*,\\\\s*\\\\d*\\\\.?\\\\d+\\\\)`; // \"(1, 2, 3, 4)\"\nconst VALUE = `(?:[+-]?\\\\d*\\\\.?\\\\d+)(?:%|[a-z]+)?`; // \".9\", \"-5px\", \"100%\".\nconst KEYWORD = `[_a-z-][_a-z0-9-]*`; // \"red\", \"transparent\", \"border-collapse\".\nconst COLOR = [`(?:`, HEX, `|`, `(?:rgb|hsl)`, RGB, `|`, `(?:rgba|hsla)`, RGBA, `|`, KEYWORD, `)`];\nconst REGEXP_ARRAY = [`\\\\s*(`, ...COLOR, `)`, `(?:\\\\s+`, `(`, VALUE, `))?`, `(?:`, COMMA, `\\\\s*)?`];\nfunction getPosition(match, stops) {\n  const fallback = stops === 1 ? `100%` : `${stops}%`;\n  return (match === null || match === void 0 ? void 0 : match.includes(`%`)) ? match : fallback;\n}\nfunction tuiParseGradient(input) {\n  const stopsRegexp = new RegExp(REGEXP_ARRAY.join(``), `gi`);\n  const stopsString = input.startsWith(`to`) || input.match(/^\\d/) ? input.slice(Math.max(0, input.indexOf(`,`) + 1)).trim() : input;\n  const side = input.startsWith(`to`) ? input.split(`,`)[0] : `to bottom`;\n  let stops = [];\n  let matchColorStop = stopsRegexp.exec(stopsString);\n  while (matchColorStop !== null) {\n    stops = stops.concat({\n      color: matchColorStop[1],\n      position: getPosition(matchColorStop[2], stops.length)\n    });\n    matchColorStop = stopsRegexp.exec(stopsString);\n  }\n  stops = stops.filter(({\n    color\n  }) => color.startsWith(`#`) || color.startsWith(`rgb`));\n  return {\n    stops,\n    side\n  };\n}\nfunction tuiParseNodeAttributes(attrs) {\n  return attrs.reduce((result, attribute) => {\n    result[attribute] = {\n      parseHTML: element => element === null || element === void 0 ? void 0 : element.getAttribute(`${attribute}`)\n    };\n    return result;\n  }, {});\n}\nfunction tuiParseStyle(style) {\n  return style.split(`;`).reduce((ruleMap, ruleString) => {\n    var _a;\n    const [left, right] = (_a = ruleString.split(`:`)) !== null && _a !== void 0 ? _a : [];\n    if (left && right) {\n      ruleMap[left.trim()] = right.trim();\n    }\n    return ruleMap;\n  }, {});\n}\nfunction tuiIsSafeLinkRange(range) {\n  var _a;\n  const textNodeLength = ((_a = range.endContainer.nodeValue) === null || _a === void 0 ? void 0 : _a.length) || 0;\n  return range.endOffset - range.startOffset > 0 || range.endOffset - range.startOffset === 0 && textNodeLength === 1 || range.startOffset !== 0 && textNodeLength > 1 && range.endOffset !== textNodeLength;\n}\nfunction tuiToGradient({\n  stops,\n  side\n}) {\n  return `linear-gradient(${side}, ${stops.map(({\n    color,\n    position\n  }) => `rgba(${tuiParseColor(color).join(`, `)}) ${position}`).join(`, `)})`;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiDeleteNode, tuiGetElementPoint, tuiGetGradientData, tuiGetMarkRange, tuiGetNestedNodes, tuiGetSelectedContent, tuiGetSelectionState, tuiInsertHtml, tuiInsertText, tuiIsSafeLinkRange, tuiIsSelectionIn, tuiLegacyEditorConverter, tuiParseGradient, tuiParseNodeAttributes, tuiParseStyle, tuiToGradient };\n"],"mappings":"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","names":["tuiDeleteNode","state","dispatch","nodeName","position","depth","hasAttributes","markAttributes","attributes","keys","key","findMarkInSet","marks","markType","attrs","type","tuiGetMarkRange","pos","node","offset","mark","startIndex","startPos","endIndex","endPos","tuiGetSelectedContent","state","current","currentNodeContent","selected","getHTMLFromFragment","tuiGetSelectionState","editor","_a","_b","_c","$from","$to","before","after","COMMA","HEX","RGB","RGBA","VALUE","KEYWORD","COLOR","REGEXP_ARRAY","tuiParseNodeAttributes","attrs","result","attribute","element","tuiParseStyle","style","ruleMap","ruleString","_a","left","right","tuiIsSafeLinkRange","range","textNodeLength"],"x_google_ignoreList":[0]}